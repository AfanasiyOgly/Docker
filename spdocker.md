# 1
## Часть 1. Готовый докер.

+ Возьмем официальный образ ngnix и скачаем его при помощи команды `sudo docker pull ngnix`

![](./images/doc1.png)

+ Удостоверимся в наличии образа с помощью команды `sudo docker images`

![](./images/doc1-1.png)

+ Запустим докер-образ через команду `sudo docker -d run [images id|repository]` и проверим, то что образ запустился с помощью команды `sudo docker ps`

![](./images/doc1-2.png)

+ Информация о контейнере через команду `sudo docker inspect [container_id|container_name]`

![](./images/doc1-3.png)

 Выясняем размер контейнера

![](./images/doc1-4.png)

Список замапленых портов

![](./images/doc1-5.png)

ip контейнера

![](./images/doc1-6.png)

+ Остановим docker-образ командой `docker stop [container_id|container_name]` и проверим, что образ успешно остановился через команду `docker ps`

![](./images/doc1-7.png)

+ Теперь запустим docker-образ с портами 80:80 и 443:443 чере команду `docker run`

![](./images/doc1-8.png)

+ Удостоверимся, что все работает, открыв в браузере страницу по адресу localhost

![](./images/doc1-9.png)

+ Перезапустим контейнер через команду `docker restart [container_id|container_name]` и проверим, что контейнер снова запустился командой `docker ps`

![](./images/doc1-10.png)

## Часть 2. Операции с контейнером.

+ Для начала прочтем конфигурационный файл nginx.conf внутри docker-контейнера через команду `docker exec`

![](./images/doc2-1.png)

+ Создаем локальный файл nginx.conf при помощи команды `touch nginx.conf` и настроем в нем выдачу страницы-статуса сервера по пути /status

![](./images/doc2-2.png)

+ Перенесем созданный файл внутрь docker-образа командой `docker cp`

![](./images/doc2-3.png)

+ Перезапустим nginx внутри docker-образа командой `docker exec [container_id|container_name] nginx -s reload`

![](./images/doc2-4.png)

+ Проверка, что все работает, проверив страницу по адресу localhost/status

![](./images/doc2-5.png)

+ Экспортируем наш контейнер в файл container.tar командой `docker export` и останавливаем контейнер командой `sudo docker stop [container_id|container_name]`

![](./images/doc2-6.png)

+ Удаляем образ командой `docker rmi -f [image_id|repository]`, не удаляя перед этим контейнеры 

![](./images/doc2-7.png)

+ После чего удалим остановленный контейнер командой `docker rm [container_id|container_name]`

![](./images/doc2-8.png)

+ Импортируем контейнер обратно командой `docker import` 

![](./images/doc2-9.png)

+ Запустим импортированный контейнер командой `dicker run`

![](./images/doc2-10.png)

+ Проверим, что по адресу localhost/status выдается страничка со статусом сервера nginx 

![](./images/doc2-11.png)

## Часть 3. Мини веб-сервер.

+ Чтобы создать свой мини веб-сервер, необходимо создать .c файл, в котором будет описана логика сервера (в нашем случае - вывод сообщения Hello World!), а также конфиг nginx.conf, который будет проксировать все запросы с порта 81 на порт 127.0.0.1:8080 

![](./images/doc3-1.png)

![](./images/doc3-2.png)

+ Качаем новый docker-образ и на его основе запускаем новый контейнер

![](./images/doc3-3.png)

+ Перносим конфигурацию и логику сервера в новый контейнер и установливаем требуемые утилиты для запуска мини веб-сервера на `FastCGI`, в частности `spawn-fcgi` и `libfcgi-dev`

![](./images/doc3-4.png)

+ Компилируем и запускаем мини веб-сервер через команду `spawn-fcgi` на порту 8080

![](./images/doc3-5.png)

![](./images/doc3-6.png)

+ Проверяем, что в браузере по localhost:81 отдается написанная вами страничка

![](./images/doc3-7.png)

## Часть 4. Свой докер.



+ Пишем свой докер образ, который:

    собирает исходники мини сервера на FastCgi из Части 3

    запускает его на 8080 порту

    копирует внутрь образа написанный `./nginx/nginx.conf`

    запускает nginx

![](./images/doc4-1.png)

![](./images/doc4-2.png)

+ Собрираем написанный докер образ через docker build при этом указав имя и тег

![](./images/doc4-3.png)

+ Проверяем через docker images, что все собралось корректно

![](./images/doc4-4.png)

+ Запускаем собранный докер образ с маппингом 81 порта на 80 на локальной машине и маппингом папки ./nginx внутрь контейнера по адресу, где лежат конфигурационные файлы nginx'а

![](./images/doc4-5.png)

+ Проверяем в браузере

![](./images/doc4-6.png)

![](./images/doc4-7.png)

## Часть 5. Dockle

+ Устанавливаем Dockle

![](./images/doc5-1.png)

+ Проверяем образ

![](./images/doc5-2.png)

+ Переписываем докер файл

![](./images/doc5-2-2.png)

+ Ошибки устранены

![](./images/doc5-3.png)

## Часть 6. Базовый Docker Compose.

+ Пишем файл docker-compose.yml

![](./images/doc6-yaml.png)



    Создаем контейнер server-part-6, который будет собран из образа задания 5

    Создауь контейнер nginx-proxy на базе образа nginx, проксирующий запросы с порта 8080 на 81 порт первого контейнера

    8080 порт второго контейнера замапим на 80 порт локальной машины
    Подключаем файл конфигурации nginx.conf из локальной директории в /etc/nginx/nginx.conf внутрь контейнера
    :ro означает read-only: контейнер сможет считывать данные из этого тома, но не сможет их изменять

+ Изменяем раздел server в файле nginx.conf для проксирования запросов

![](./images/doc6-nginx.png)

+ Поднимаем командами sudo docker-compose up -d 

![](./images/doc6-2.png)

+ Собраем и запускаем проект с командой sudo docker build -t kenyaqui:1.0 .

![](./images/doc6-3.png)

+ Проверяем в браузере

![](./images/doc6-5.png)

![](./images/doc6-6.png)

